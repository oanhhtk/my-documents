# Section 1: Introduction to GitLab CI/CD. Fundamental CI/CD concepts & DevOps

- [1. Introduction to the GitLab CI/CD course](#-introduction)
- [2. What is GitLab CI/CD?](#%EF%B8%8Fwhat-is-gitlab-cicd)
- [3. GitLab.com account registration](#-registration)
- [4. Verifying your GitLab account](#verification)
- [5. What is a pipeline?](#what-is-a-pipeline)
- [6. Your first pipeline](#your-first-pipeline)
- [7. Adding pipeline stages](#adding-pipeline-stages)
- [8. GitLab CI/CD architecture](#gitlab-cicd-architecture)

--- title: "Section 1: Introduction to GitLab CI/CD. Fundamental CI/CD concepts & DevOps"

## ðŸ”®Introduction

KhÃ³a há»c giá»›i thiá»‡u GitLab CI/CD, giÃºp ngÆ°á»i há»c tá»± Ä‘á»™ng hÃ³a quy trÃ¬nh build, test vÃ  deploy. Giáº£ng viÃªn Valentin giáº£i thÃ­ch dá»… hiá»ƒu, táº­p trung vÃ o giáº£m thao tÃ¡c thá»§ cÃ´ng báº±ng automation. Ná»™i dung báº¯t Ä‘áº§u tá»« kiáº¿n thá»©c cÆ¡ báº£n, kÃ¨m vÃ­ dá»¥ thá»±c hÃ nh vÃ  Ã¡p dá»¥ng Ä‘Æ°á»£c cho nhiá»u ngÃ´n ngá»¯/framework. Káº¿t thÃºc khÃ³a há»c, há»c viÃªn cÃ³ thá»ƒ tá»± xÃ¢y dá»±ng pipeline CI/CD hoÃ n chá»‰nh.

## âš™ï¸What is GitLab CI/CD?

GitLab CI/CD lÃ  cÃ´ng cá»¥ tá»± Ä‘á»™ng hÃ³a trong GitLab giÃºp build, test vÃ  deploy pháº§n má»m. NÃ³ hoáº¡t Ä‘á»™ng nhÆ° â€œtrá»£ lÃ½ robotâ€, cháº¡y cÃ¡c bÆ°á»›c tá»± Ä‘á»™ng qua pipeline Ä‘á»ƒ giáº£m lá»—i vÃ  tiáº¿t kiá»‡m thá»i gian. Há»‡ thá»‘ng liÃªn tá»¥c kiá»ƒm tra mÃ£ nguá»“n má»—i khi cÃ³ thay Ä‘á»•i, Ä‘áº£m báº£o phÃ¡t hiá»‡n lá»—i sá»›m. KhÃ³a há»c táº­p trung vÃ o ná»n táº£ng DevOps cho ngÆ°á»i má»›i, cung cáº¥p kiáº¿n thá»©c vÃ  ká»¹ nÄƒng Ä‘á»ƒ tá»± xÃ¢y dá»±ng pipeline cho báº¥t ká»³ cÃ´ng nghá»‡ nÃ o.

## âŒ‡ What is a pipeline?

DÆ°á»›i Ä‘Ã¢y lÃ  pháº§n giáº£i thÃ­ch dáº¡ng gáº¡ch Ä‘áº§u dÃ²ng, ngáº¯n gá»n vÃ  dá»… hiá»ƒu:

- **Pipeline lÃ  gÃ¬?**  
  Má»™t chuá»—i bÆ°á»›c tá»± Ä‘á»™ng giÃºp build, test vÃ  deploy pháº§n má»m.

- **VÃ­ dá»¥ dá»… hiá»ƒu (Analogies):**  
  Giá»‘ng nhÆ° **dÃ¢y chuyá»n láº¯p rÃ¡p Ã´ tÃ´** â€“ má»—i cÃ´ng Ä‘oáº¡n pháº£i hoÃ n thÃ nh trÆ°á»›c khi sang bÆ°á»›c tiáº¿p theo.

- **Äáº·c Ä‘iá»ƒm chÃ­nh cá»§a pipeline:**

  - CÃ¡c bÆ°á»›c cháº¡y **tuáº§n tá»±** náº¿u phá»¥ thuá»™c nhau.
  - CÃ¡c bÆ°á»›c cÃ³ thá»ƒ cháº¡y **song song** náº¿u Ä‘á»™c láº­p.

- **Jobs trong pipeline:**

  - ÄÆ°á»£c Ä‘á»‹nh nghÄ©a trong file **`.gitlab-ci.yml`**.
  - Viáº¿t báº±ng cÃº phÃ¡p **YAML** Ä‘á»ƒ mÃ´ táº£ tá»«ng nhiá»‡m vá»¥.

- **Khi nÃ o pipeline cháº¡y?**

  - Khi cÃ³ thay Ä‘á»•i trong repository (commit/push).
  - GitLab sáº½ tá»± Ä‘á»™ng kÃ­ch hoáº¡t pipeline.

- **ThÃ nh pháº§n váº­n hÃ nh:**

  - **GitLab Server:** quáº£n lÃ½, theo dÃµi, hiá»ƒn thá»‹ káº¿t quáº£ pipeline.
  - **GitLab Runner:** mÃ¡y thá»±c thi cÃ¡c job trong pipeline.

- **Má»¥c tiÃªu cá»§a pipeline:**  
  Äáº£m báº£o pháº§n má»m Ä‘Æ°á»£c build â€“ test â€“ triá»ƒn khai má»™t cÃ¡ch tá»± Ä‘á»™ng, á»•n Ä‘á»‹nh vÃ  cháº¥t lÆ°á»£ng.

## ðŸªƒ Your first pipeline

Creating a Simple CI/CD Pipeline in GitLab  
_A car assembly line analogy for understanding pipelines_

### 1. Introduction to CI/CD Pipeline

- A **CI/CD pipeline** is a series of automated steps such as **build**, **test**, and **deploy**.
- GitLab executes these steps automatically whenever changes are pushed.
- The pipeline flow is compared to a **car assembly line**, where each job performs its own task.

---

### 2. Creating a New GitLab Project

- Project name used in the lecture: **`car assembly`**.
- Key points while creating a project:
  - Set **project visibility** (private, internal, public).
  - Initialize repository with a **README** file for convenience.

---

### 3. Using the Web IDE

- Open GitLabâ€™s **Web IDE** to start editing files.
- Create a new file named **`.gitlab-ci.yml`**, which defines the pipeline.
- The pipeline is written in **YAML format**, requiring careful indentation.

---

### 4. Defining Jobs in GitLab CI/CD

- A **job** = one task in the pipeline (similar to one station in a car assembly line).
- Instructor creates the job:

  - `build_car` : Job name (Example: `build`, `test`, `deploy`)

  - In a pipeline, every job is like a station in the car assembly line.

- Example .gitlab-ci.yml

- Jobs run inside **Docker containers**.
- Docker image used:

  ```yaml
  build_car:
    # Choosing a lightweight Docker image
    image: alpine # Alpine Linux is chosen because it is minimal and fast.
    # Write the script for the job
    script:
      - echo "Starting car assembly"
      - mkdir build # mkdir â†’ creates a new directory
      - touch build/car.txt # touch â†’ creates an empty file
      - echo "This is a car file" > build/car.txt # echo â†’ prints messages
  ```

  The instructor emphasizes correct YAML indentation, or the pipeline will fail.

---Explanation of Commands Used: ---

- `build_car`: â€” Job name

- This is the identifier of the job.

- You can name jobs anything you want (build, test, deploy, etc.), but meaningful names are recommended.

- In a pipeline, every job is like a station in the car assembly line.

- `image`: alpine â€” Docker image to run the job

- Tells the runner to create a Docker container using the alpine image.

- Alpine is a lightweight Linux distribution commonly used for simple tasks.

- All commands in script will run inside this container.

- Note: If your runner does NOT use Docker (example: Shell runner), the image field will be ignored.

  - `script`: â€” Commands to execute

## Adding pipeline stages

In Lesson 8, _â€œAdding pipeline stages,â€_ the instructor goes deeper into how CI/CD pipelines work in GitLab. The lesson focuses on improving pipeline structure, automating checks, understanding job isolation, and using artifacts to pass files between jobs.

---

### 1. Displaying File Contents

- Using the `cat` command to display file contents in the job logs.
  ```yaml
  test_car:
    image: alpine
    script:
      - echo "Testing car assembly"
      - cat build/car.txt # Display the contents of car.txt
  ```
- This helps verify that the previous job created the file correctly.

### 2. Automating File Checks

- A new job named `test_car` is introduced.
- The job employs commands like `test` to confirm the existence of `car.txt` and `grep` to search for specific contents within the file.
- This job is crucial for automating the verification process.

  ```yaml
  test_car:
    image: alpine
    script:
      - echo "Testing car assembly"
      - test -f build/car.txt # Check if car.txt exists
      - grep "This is a car file" build/car.txt # Search for specific content
  ```

### 3. Pipeline Execution Analysis

- By default, GitLab runs jobs in parallel unless specified otherwise.
- To enhance the pipeline logic, stagesâ€”like build and testâ€”are specifically defined

```yaml
stages:
  - build
  - test
```

- Then each job is assigned to a stage:

```yaml
build_car:
  stage: build

test_car:
  stage: test
```

=> This ensures:
`build_car` runs first

`test_car` runs only after build_car finishes successfully

- This ensures jobs run sequentially instead of simultaneously, allowing for a more orderly process.

  ```yaml
  stages: # Defining pipeline stages, the order matters, from top to bottom
    - build
    - test

  build_car:
    stage: build # Assigning the job to the 'build' stage
    image: alpine
    script:
      - echo "Starting car assembly"
      - mkdir build
      - touch build/car.txt
      - echo "This is a car file" > build/car.txt

  test_car:
    stage: test # Assigning the job to the 'test' stage
    image: alpine
    script:
      - echo "Testing car assembly"
      - test -f build/car.txt # Check if car.txt exists
      - grep "This is a car file" build/car.txt # Search for specific content
  ```

### 4. Introducing Job Artifacts

- To allow one jobâ€™s output to be used by another job, GitLab provides artifacts.

**Artifacts**:

- Save files created during a job

- Make them available to later jobs

- Allow downstream tasks (like testing or deployment) to use the output

This is the correct way to pass files between build â†’ test â†’ deploy stages.

**Configuring Artifacts:**

```yaml
build_car:
  stage: build
  image: alpine
  script:
    - echo "Starting car assembly"
    - mkdir build
    - touch build/car.txt
    - echo "This is a car file" > build/car.txt
  artifacts:
    paths:
      - build/car.txt # Specify files to be saved as artifacts

test_car:
  stage: test
  image: alpine
  script:
    - echo "Testing car assembly"
    - test -f build/car.txt # Check if car.txt exists
    - grep "This is a car file" build/car.txt # Search for specific content
```

## GitLab CI/CD architecture

![GitLab CI/CD architecture](/gitlab-cicd/gitlab-architecture.png)

### 1. Pipeline Triggering

- A pipeline is automatically triggered whenever there are changes in the repository  
  (such as adding or modifying files, commits, or pushes).

### 2.Core Components

- **GitLab Server**
  - Manages pipeline execution
  - Tracks `job status` and `stores results`
  - Acts like a **director** coordinating all tasks
- **GitLab Runner**
  - Executes the jobs defined in the `pipeline`
  - Acts like **agents/workers** performing the actual work

### 3. Job Execution

- Each **job runs independently** from others
- Example job: `build_car`, which has two main phases:
  - Preparation
  - Execution

### 4. Preparation Phase

- Selects an appropriate runner
- Get required secrets and variables
- Prepares the executor environment
- Commonly uses a **Docker executor**

### 5. Execution Phase

- The runner pulls the specified Docker image
- Init a Docker container
- Fetches the source code from Git
- Executes the defined commands
- Uploads generated artifacts after completion

### 6. Artifact Management

- After a job finishes:
  - The Docker container is removed to optimize resource usage
- The next job (e.g., `test_car`):
  - Downloads artifacts from previous jobs
  - Reuses build results instead of rebuilding

### 7. Note on Executing Jobs with Different Runners

- **Default Docker Image**

  - If no Docker image is defined in a job, GitLab runners use a default image.
  - The default image is typically **Ruby-based**.

- **Storage of Build Artifacts**

  - Build outputs (e.g. `build/` directory, `car.txt`) are stored by GitLab internally.
  - The exact physical storage location is abstracted and managed by GitLab
  - Developers cant (no need) access these files

- **Docker Execution Overhead**

  - Using Docker introduces some overhead:
    - Pulling Docker images
    - Starting containers
  - However, this overhead is acceptable due to the benefits of an **isolated and consistent build environment**.

- **Using Lightweight Images**

  - Lightweight images (e.g. Alpine) help:
    - Reduce image size
    - Decrease job startup time
    - Improve overall pipeline performance

- **Troubleshooting with Architecture Knowledge**
  - Understanding CI/CD architecture makes troubleshooting easier.
  - Job logs are key to identifying issues during execution.
